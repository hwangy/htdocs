var canvas  = document.getElementById("fractal");
var context = canvas.getContext("2d");
var canvasData;

var keyArray = [0, 0];

function saveImg() {
	var img = canvas.toDataURL("image/png").replace("image/png", "image/octet-stream");
	window.location.href = img;
}

function complex(r, i) {
	this.real = r;
	this.imaginary = i;
}

complex.prototype.add = function(a) {
	this.real += a.real;
	this.imaginary += a.imaginary;
};

complex.prototype.multiply = function(a) {
	var realTmp = this.real * a.real -
			this.imaginary * a.imaginary;
	this.imaginary = this.imaginary * a.real +
			this.real * a.imaginary;
	this.real = realTmp;
};

complex.prototype.square = function() {
	var realTmp  = this.real * this.real -
			this.imaginary * this.imaginary;
	this.imaginary = 2 * this.real * this.imaginary;
	this.real = realTmp;
};

fractal = {
	initted: 0,
	width: canvas.width,
	height: canvas.height,
	fps: 60,
	MinR: -2.0,
	MaxR: 2.0,
	MinI: -2.0,
	MaxI: 2.0,
	iterations: 100,
	rmax: 30,
	mouse: {x: 0, y: 0},
	mouseStart: {x: 0, y: 0},
	mouseDown: 0,
	thread: 0,
	RENDER_DISTANCE: 5,
	progress: 0,

	bufferedDisplay: 0,

	update: function() {
		if (!fractal.initted) {
			thread = new Worker("projects/buffer.js");
			/*bufferedDisplay = new Uint32Array(fractal.RENDER_DISTANCE*fractal.RENDER_DISTANCE*
						fractal.width*fractal.height*Uint8ClampedArray.BYTES_PER_ELEMENT);*/

			//Tasks for very first frame
			thread.addEventListener('message', function(e) {
				var data = e.data;
				switch (data.type) {
					case 'data':
						console.log("Received Buffer");
						bufferedDisplay = new Uint32Array(data.buffer);
						console.log(bufferedDisplay[500]);
						break;
					case 'prog':
						console.log("Received progress");
						progress = data.prog;
						break;
					default:
						console.log("Unrecognized transmission");
				};
			}, false);
			thread.postMessage({
				'MinR': fractal.MinR,
				'MaxR': fractal.MaxR,
				'MinI': fractal.MinI,
				'MaxI': fractal.MaxI,
				'dimX': fractal.width,
				'dimY': fractal.height,
				'iterations': fractal.iterations,
				'rmax': fractal.rmax,
				'RENDER_DISTANCE': fractal.RENDER_DISTANCE
			});

			canvasData = context.createImageData(fractal.width, fractal.height);
			fractal.initted = 1;
		}
		if (fractal.initted < 2) {
			for (var x = 0; x < fractal.width; x++) {
				for (var y = 0; y < fractal.height; y++) {
					var tmp = fractal.getColor(x, y);
					var r = tmp/(256*256);
					var g = (tmp - (r | 0)*256*256)/256;
					var b = (tmp - (r | 0)*256*256 - (g | 0)*256);
					fractal.color(x, y, r, g, b, 256);
				}
			}
	
			context.putImageData(canvasData, 0, 0);

			//saveImg();
			fractal.initted = 2;
		}
		setTimeout(fractal.update, 10);
	},

	color: function(x, y, r, g, b, a) {
		var index = (x + y*canvasData.width) * 4;
		canvasData.data[index + 0] = r;
		canvasData.data[index + 1] = g;
		canvasData.data[index + 2] = b;
		canvasData.data[index + 3] = a;
	},

	getColor: function(x, y) {
		var ref = (fractal.MaxR - fractal.MinR)/fractal.width;
		var imf = (fractal.MaxI - fractal.MinI)/fractal.height;

		var val = new complex(fractal.MinR+x*ref, fractal.MaxI - y*imf);
		var z = new complex(val.real, val.imaginary);
		var count = 0;
		while (count < fractal.iterations && z.real + z.imaginary < fractal.rmax) {
			var tmp = z.square();
			z.add(val);
			count++;
		}
		//console.log(count);

		return ((count == fractal.iterations)?0:0xFFFFFF*(count/fractal.iterations));
	}
};

function processMouse(e) {
	fractal.mouseDown = 1;

	fractal.mouseStart = canvas.relMouseCoord(e);
}

function endMouse(e) {
	fractal.mouseDown = 0;
}

function moveMouse(e) {
	/*fractal.mouse.x = canvas.relMouseCoord(e).x;
	fractal.mouse.y = canvas.relMouseCoord(e).y;*/

	fractal.mouse = canvas.relMouseCoord(e);
}

function processKey(e) {
	if (e.keyCode == 82) keyArray[0] = 1;	//R
}

function endKey(e) {
	if (e.keyCode == 82) keyArray[0] = 0;	//R
}

function relMouseCoord(e) {
	var totalOffsetX = 0;
	var totalOffsetY = 0;
	var canvasX = 0;
	var canvasY = 0;
	var currentElement = this;
	
	while (currentElement = currentElement.offsetParent) {
		totalOffsetX += currentElement.offsetLeft - currentElement.scrollLeft;
		totalOffsetY += currentElement.offsetTop - currentElement.scrollTop;
	}

	canvasX = e.pageX - totalOffsetX;
	canvasY = e.pageY - totalOffsetY;
	return {x:canvasX, y:canvasY};
}

HTMLCanvasElement.prototype.relMouseCoord = relMouseCoord;

this.canvas.addEventListener('mousedown', this.processMouse, false);
this.canvas.addEventListener('mouseup', this.endMouse, false);
this.canvas.addEventListener('mousemove', this.moveMouse, false);

addEventListener('keydown', this.processKey, false);
addEventListener('keyup', this.endKey, false);

fractal.update();
